# 线程池 ThreadPool

- 环境：Ubuntu 22.04.1
- 项目描述
  - 基于可变参模板编程和引用折叠原理，实现线程池submitTask接口，支持任意任务函数和任意参数的传递
  - 使用map和queue容器管理线程对象和任务
  - 使用future类型定制submitTask提交任务的返回值
  - 基于条件变量condition_variable和互斥锁mutex实现任务提交线程和任务执行线程间的通信机制
- 关键技术：
  - C++11标准的面向对象编程：智能指针，绑定器，可变参模板编程等
  - C++11的多线程编程：thread、mutex、atomic、condition_variable、unique_lock 等
  - C++14的 make_unique 等接口

## 文件目录

```shell
.
├── main.cpp	// 需要实现的功能
├── makefile	// makefile
├── threadpool.cpp	// 线程池的具体实现
└── threadpool.h
```

## 功能介绍

- **线程池优势**：在服务启动之初，就是先船舰好线程池里面的线程。由于操作系统上创建线程和销毁线程都是很"重"的操作，耗时耗性能都比较多，那么在服务执行的过程中，如果业务量比较大，实时的去创建线程、执行业务、业务完成后销毁线程，那么会导致系统的实时性能降低，业务的处理能力也会降低。因此，设计线程池，当业务流量到来时需要分配线程，直接从线程池中获取一个空闲线程执行task任务即可，task执行完成后，也不用释放线程，而是把线程归还到线程池中继续给后续的task提供服务。
- **Fixed模式线程池**：线程池里面线程的个数是固定不变的，默认初始化为当前服务器的CPU核心数量。

- **Cached模式线程池**：线程池里面的线程数量可以动态增长，但不会无限制增长。当任务处理完，在一定长的时间之后，若线程仍空闲，将默认线程池大小之外的线程进行关闭，保持池中初始线程数量。
- **迁移到个人项目中**：可以参考`main.cpp`中的实现方法，只需对想要实现的任务的函数进行编写，并把整个函数当作参数，和需要的形参通过线程池的**submitTask**方法提交任务，即可正常使用。

## 运行

```bash
cd ThreadPool
./make
```

```bash
./result
```

